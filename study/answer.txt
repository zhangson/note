区别T-SQL是语言，存储过程是数据库一种对象
T-SQL 即 Transact-SQL，是 SQL 在 Microsoft SQL Server 上的增强版，它是用来让应用程式与 SQL Server 沟通的主要语言。
Transact-SQL中的存储过程，非常类似于Java语言中的方法，它可以重复调用。当存储过程执行一次后，可以将语句缓存中，这样下次执行的时候直接使用缓存中的语句。这样就可以提高存储过程的性能。
Ø 存储过程的概念
存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。
存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参数、返回单个或多个结果集以及返回值。
由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
mysql> create  table stu(id int  primary key auto_increment,name char(10),age tinyint default 18 );
mysql> insert into  stu(name)values("bob"),("lucy");
mysql> select  * from stu;
mysql> delete from stu;
mysql> alter table stu AUTO_INCREMENT=0;

+++++++++++++++++++++++++++++++++++++++++++++

char     char是定长的，也就是当你输入的字符小于你指定的数目时，char(8)，你输入的字符小于8时，它会再后面补空值。当你输入的字符大于指定的数时，它会截取超出的字符。    nvarchar(n)     包含 n 个字符的可变长度 Unicode 字符数据。n 的值必须介于 1 与 4,000 之间。字节的存储大小是所输入字符个数的两倍。所输入的数据字符长度可以为零。        varchar[(n)]       长度为 n 个字节的可变长度且非 Unicode 的字符数据。n 必须是一个介于 1 和 8,000 之间的数值。存储大小为输入数据的字节的实际长度，而不是 n 个字节。所输入的数据字符长度可以为零。 1、CHAR。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间。 

 2、VARCHAR。存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么“+1”呢？这一个字节用于保存实际使用了多大的长度。   从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。   3、TEXT。text存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。   4、NCHAR、NVARCHAR、NTEXT。这三种从名字上看比前面三种多了个“N”。它表示存储的是Unicode数据类型的字符。我们知道字符中，英文字符只需要一个字节存储就足够了，但汉字众多，需要两个字节存储，英文与汉字同时存在时容易造成混乱，Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。nchar、nvarchar的长度是在1到4000之间。和char、varchar比较起来，nchar、nvarchar则最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。  

所以一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。

 

1. char
     固定长度，最长n个字符。
 
2. varchar
     最大长度为n的可变字符串。
（n为某一整数，不同数据库，最大长度n不同）
 
char和varchar区别：
     varchar必char节省空间，但在效率上比char稍微差一些。
     说varchar比char节省空间，是因为varchar是可变字符串，比如：用varchar(5)存储字符串“abc”，只占用3个字节的存储空间，而用char(5)存储，则占用5个字节（“abc  ”）。
     说varchar比char效率稍差，是因为，当修改varchar数据时，可能因为数据长度不同，导致数据迁移（即：多余I/O）。其中，oracle对此多余I/O描述的表达是：“行迁移”（Row Migration）。
 
“行迁移”（Row Migration）：
      “当一行的记录初始插入时是可以存储在一个block中的，由于更新操作导致行增加了，而block的自由空间已经完全满了，这个时候就产生了行迁移。在这种情况下，oracle将会把整行数据迁移到一个新的block中，oracle会保留被迁移的行的原始指针指向新的存放行数据的block，这就意味着被迁移行的ROW ID是不会改变的。"
     其中要解释一下：block是oracle中最小的数据组织与管理单位，是数据文件磁盘储存空间单位，也是数据库I/O最小单位（也就是说，读和写都是一个block打大小，所以如果block没满时，更新内容长度变更的varchar字段，和更新内容长度没变的varchar字段，I/O次数是一样，不存在额外消耗，只有在block满时，才会出现额外I/O，所以char和varchar性能之间的性能差异，是相当细微的，绝大多数情况下可以忽略不计，所以上文描述的“稍”差的含义）。
     所以，我的开发经验是：“用varchar完全代替char吧，没什么好顾虑的”。
 
3. nvarchar
     nvarchar的特性，需要和varchar对比。
     nvarchar和varchar的不同主要是在对于数据的存储方式上：
     1). varchar：按字节存储数据
          varchar(6)，最多能存储6个字节的数据，比如：“哈哈哈”，“abcdef”......
备注：一个中文字符在数据库里占多少个字节，要看unicode的编码方式，比如：utf8在mysql上占3个字节，sqlserver的Chinese_PRC_CI_AS占2个字节...
     2). nvarchar：按字符存储数据
          nvarchar(6)，最多能存储6个字符/中文数据，比如："哈哈哈哈哈哈"，“abcdef”......
          nvarchar(m)最大存储的实际字节长度=n*m(n跟据编码方式而定)，如果nvarchar存储的是英文字符，也是根据编码方式存储n的字节长度。也就是说，如果用nvarchar存储英文字符，会浪费一半以上的存储空间....
          
总结：
     1. char和varchar的性能差距是很小的，可以考虑忽略不计。
     2. 在大数据量应用中，使用char和nvarchar有可能导致大量的存储空间的浪费。
 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++
一、索引的类型

mysql索引的四种类型：主键索引、唯一索引、普通索引和全文索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。索引优化时mysql中的一种优化方式。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

主键索引: 
        主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。

唯一索引: 
        索引列的所有值都只能出现一次，即必须唯一，值可以为空。


普通索引 : 
        基本的索引类型，值可以为空，没有唯一性的限制。


全文索引: 
        全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建。可以通过ALTER TABLE或CREATE INDEX命令创建。对于大规模的数据集，通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快。MyISAM支持全文索引，InnoDB在mysql5.6之后支持了全文索引。   alter table 表名 add FULLTEXT(`字段名`);


三、索引的机制

1.为什么我们添加完索引后查询速度为变快？
    传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，mysql需要将表的数据从头到尾遍历一遍
    在我们添加完索引之后，mysql一般通过BTREE算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历(折半查找大幅查询效率)，找到相应的键从而获取数据
    Hash或B+Tree索引


2.索引缺点
    2.1创建索引是为产生索引文件的，占用磁盘空间
    2.2索引文件是一个二叉树类型的文件，可想而知我们的dml操作同样也会对索引文件进行修改，所以性能会下降

3.在哪些字段上创建索引？
    3.1较频繁的作为查询条件字段应该创建索引 
    3.2唯一性太差的字段不适合创建索引，尽管频繁作为查询条件，例如gender性别字段
    3.3更新非常频繁的字段不适合作为索引
    3.4不会出现在where子句中的字段不该创建索引

总结: 满足以下条件的字段，才应该创建索引.
1 在where条经常使用 
2 该字段的内容不是唯一的几个值 
3  字段内容不是频繁变化。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[root@host50 ~]# which mysqlcheck
/usr/bin/mysqlcheck
[root@host50 ~]# man mysqlcheck

[root@host50 ~]# which myisamchk
/usr/bin/myisamchk
[root@host50 ~]# man  myisamchk

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
information_schema  是一个信息数据库，它保存着关于MySQL服务器已有库的信息。

mysql  存储数据库已有的授权用户及权限


performance_schema 主要用于收集数据库服务器性能参数。

sys库所有的数据源来自：performance_schema。
+++++++++++++++++++++++++++++++++++++++++++++++
云服务类型： IaaS, PaaS  SaaS
IaaS: Infrastructure-as-a-Service（基础设施即服务）
PaaS: Platform-as-a-Service（平台即服务）
SaaS: Software-as-a-Service（软件即服务）
++++++++++++++++++++++++++++++++++++++++
视图的功能实际上是封装查询语句,封装实现查询常量语句的视图即是常量视图
mysql> create view v2 as  select  222;

delimiter //
create procedure pline(in x int) 
begin
declare i int default 1;
select i;
select x;
while i <= x do
 select * from user where uid % 2 = 0 limit x;
 set i = i  + x;
end while;
end
//
delimiter ;

+++++++++++++++++++++++++++++++++++++++++++++

MongoDB 一个基于分布式文件存储的数据库
json  svn
库
集合
文档
+++++++++++++++++++++++++++++++++++++++++++++
MongoDB-GridFS 网格文件系统
    mongoDB的文档以BSON格式存储，支持二进制数据类型，所以，可以把文件的二进制格式的数据直接保存到MongoDB的文档中，但是每个文档的长度是有限制的，而我们一般上传的图片、视频等文件又比较大。针对这种情况，mongoDB提供了一种处理大文件的规范——GridFS。

将要存储的文件分成若干块儿，每一块作为一个单独的文档来存储，每块默认大小为256k。用两个集合来存储一个文件：
fs.files（存储文件信息）
fs.chunks（存储文件的数据）







