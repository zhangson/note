1.什么是数据库事务？

事务是最小的逻辑工作单元。

事务特性(ACID)

1).原子性:一个事务里面的操作要么不做,要么都做;

2).一致性:事务启动之前和启动之后要保持平衡状态

例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。

3).隔离性:在一个会话里面读取不到另一个会话里未提交的数据.

4).永久性:事务一经提交永不回退。

++++++++++++++++++++++++++++++++++++++++++
2.mysql的常用引擎？所使用的索引的数据结构分别是什么？

在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM

1).MyISAM，表锁，不支持事务，表损坏率较高，分为MYD数据文件和MYI索引二个文件，读写并发不如InnoDB，适用于insert较多的场景，且支持直接复制文件，用以备份数据。

2).InnoDB，行锁，支持事务，crash后具有recove机制，只有ibd文件，分为数据区和索引区，有较好的读写并发能力，但做count()运算时相当消耗CPU。

所使用的索引的数据结构都是B树。

MyIASM引擎，B树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

3.在创建和使用索引时，有哪些要注意的地方，有什么规则？

1).避免索引过多，会影响写性能.

2).给筛选效果低的字段加索引，几乎无效，如性别、状态标志等.

3).每条查询执行时，只会使用一个索引，有需要时应该创建复合索引.

4).复合索引使用时遵守“从左到右”原则，严禁左百分号.

5).不要在索引字段上有运算操作和使用函数，将无法使用索引
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4.SQL语句分为哪几种？

SQL语句主要可以划分为以下几类：

1).DDL(Data Definition Language):数据定义语言，定义对数据库对象(库、表、列、索引)的操作。

包括：CREATE、DROP、ALTER、RENAME、 TRUNCATE等

2).DML(Data Manipulation Language): 数据操作语言，定义对数据库记录的操作。

包括：INSERT、DELETE、UPDATE、SELECT等

3).DCL(Data Control Language): 数据控制语言，定义对数据库、表、字段、用户的访问权限和安全级别。

包括：GRANT、REVOKE等

4).Transaction Control:事务控制

包括：COMMIT、ROLLBACK、SAVEPOINT等

5.Delete、truncaate、drop都是删除语句，它们有什么分别？

1).delete 属于DML语句，删除数据，保留表结构，需要commit，可以回滚，如果数据量大，很慢。

2).truncate 属于DDL语句，删除所有数据，保留表结构，自动commit，不可以回滚，一次全部删除所有数据，速度相对较快。

3).Drop属于 DDL语句，删除数据和表结构,不需要commit，删除速度最快。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6.MySQL原生支持的备份方式有哪些，并说出其优缺点？

1).直接拷贝数据文件，必须是MyISAM表，且使用flush tables with read lock;语句，优点是简单方便，缺点是须要锁写，且只能在同版本的MySQL上恢复使用。

2). mysqldump，导出的是SQL语句，所以可以跨版本恢复，但是需要导入数据和重建索引，恢复用时会较长，如果是MyISAM表，同样需要锁表，如果是InnoDB表，可以使用--single-transaction参数避免此。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

7.什么情况下应不建或少建索引

表记录太少

如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，这种情况下DB至少要往返读取数据块两次。而不用索引的情况下DB会将所有的数据一次读出，处理速度显然会比用索引快。

经常插入、删除、修改的表 对一些经常处理的业务表应在查询允许的情况下尽量减少索引。

数据重复且分布平均的表字段

假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
8.mysql和oracle的区别？

1). Oracle是大型数据库而Mysql是中小型数据库，市场占有率达   同时Mysql是开源的而Oracle价格非常高。

2). Oracle支持大并发，大访问量

3). 安装所用的空间差别也是很大的，Mysql安装完后才152M而Oracle有3G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。

4).Oracle也Mysql操作上的一些区别

①自动增长类型的处理

MYSQL有自动增长的数据类型，插入记录时不用操作此字段，会自动获得数据值。ORACLE没有自动增长的数据类型，需要建立一个自动增长的序列号，插入记录时要把序列号的下一个值赋于此字段。

②单引号的处理

MYSQL里可以用双引号包起字符串，ORACLE里只可以用单引号包起字符串。

③分页的SQL语句的处理

MYSQL处理分页的SQL语句比较简单，用LIMIT 开始位置, 记录个数；ORACLE处理分页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置, 并且只能用ROWNUM<100, 不能用ROWNUM>80

④ 长字符串的处理

ORACLE也有它特殊的地方。INSERT和UPDATE时最大可操作的字符串长度小于等于4000个单字节, 如果要插入更长的字符串, 请考虑字段用CLOB类型，方法借用ORACLE里自带的DBMS_LOB程序包。插入修改记录前一定要做进行非空和长度判断，不能为空的字段值和超出长度字段值都应该提出警告,返回上次操作。

⑤空字符的处理

MYSQL的非空字段允许为空字符串，ORACLE里定义了非空字段就不容许为空字符串。

⑥字符串的模糊比较

MYSQL里用 字段名 like '%字符串%',ORACLE里也可以用 字段名 like '%字符串%' 但这种方法不能使用索引, 速度不快。

⑦日期字段的处理

MYSQL日期字段分DATE和TIME两种，ORACLE日期字段只有DATE，包含年月日时分秒信息，用当前数据库的系统时间为SYSDATE, 精确到秒

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
9.数据库的锁：行锁，表锁；乐观锁，悲观锁

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。不能解决脏读问题

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
10. MySQL服务器CPU跑满100%的情况分析
1.第一步,万能的重启.当然可能重启了一会儿还是继续高上去

2.检查连接数和慢查询语句.开始分析了.

我们的原则是,重启能解决的,绝对不开client

cpu100%通常情况下就是有慢sql造成的，这里的慢sql包括全表扫描，扫描数据量过大，内存排序，磁盘排序，锁争用等待等...

一般表现现象sql执行状态为：Sending data，Copying to tmp table，Copying to tmp table on disk，Sorting result，locked

通过show processlist查看当前正在执行的sql，当执行完show processlist后出现大量的语句，通常其状态出现Sending data，Copying to tmp table，Copying to tmp table on disk，Sorting result, Using filesort都是sql有性能问题

可以用explain查看sql执行效率,分析索引

解决方案整理

1.Sending data表示：sql正在从表中查询数据，如果查询条件没有适当的索引，则会导致sql执行时间过长；

2.Copying to tmp table on disk：出现这种状态，通常情况下是由于临时结果集太大，超过了数据库规定的临时内存大小，需要拷贝临时结果集到磁盘上，这个时候需要用户对sql进行优化；

3.Sorting result, Using filesort：出现这种状态，表示sql正在执行排序操作，排序操作都会引起较多的cpu消耗，通常的优化方法会添加适当的索引来消除排序，或者缩小排序的结果集；

4.出现sending data的情况：这种一般就是SQL不规范,优化SQL吧.

5.检查网站是不是有被攻击之类的
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
11、mysql优化
1 优化你的MySQL查询缓存
2 用EXPLAIN使你的SELECT查询更加清晰：了解MySQL正在进行什么样的查询操作，这可以帮助你发现瓶颈的所在，并显示出查询或表结构在哪里出了问题。
EXPLAIN查询的结果，可以告诉你那些索引正在被引用，表是如何被扫描和排序的等等。
3 尽量避免SELECT *命令



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
12 innobackupex 备份过程
PXB 备份过程

innobackupex 在启动后，会先 fork 一个进程，启动 xtrabackup进程，然后就等待 xtrabackup 备份完 ibd 数据文件；
xtrabackup 在备份 InnoDB 相关数据时，是有2种线程的，1种是 redo 拷贝线程，负责拷贝 redo 文件，1种是 ibd 拷贝线程，负责拷贝 ibd 文件；redo 拷贝线程只有一个，在 ibd 拷贝线程之前启动，在 ibd 线程结束后结束。xtrabackup 进程开始执行后，先启动 redo 拷贝线程，从最新的 checkpoint 点开始顺序拷贝 redo 日志；然后再启动 ibd 数据拷贝线程，在xtrabackup 拷贝 ibd 过程中，innobackupex 进程一直处于等待状态（等待文件被创建）。
xtrabackup 拷贝完成idb后，通知innobackupex（通过创建文件），同时自己进入等待（redo 线程仍然继续拷贝）;
innobackupex 收到 xtrabackup 通知后，执行FLUSH TABLES WITH READ LOCK(FTWRL)，取得一致性位点，然后开始备份非 InnoDB 文件（包括 frm、MYD、MYI、CSV、opt、par等）。拷贝非 InnoDB 文件过程中，因为数据库处于全局只读状态，如果在业务的主库备份的话，要特别小心，非 InnoDB 表（主要是MyISAM）比较多的话整库只读时间就会比较长，这个影响一定要评估到。
当 innobackupex 拷贝完所有非 InnoDB 表文件后，通知 xtrabackup（通过删文件） ，同时自己进入等待（等待另一个文件被创建）；
xtrabackup 收到 innobackupex 备份完非 InnoDB 通知后，就停止 redo 拷贝线程，然后通知 innobackupex redo log 拷贝完成（通过创建文件）；
innobackupex 收到 redo 备份完成通知后，就开始解锁，执行 UNLOCK TABLES；
最后 innobackupex 和 xtrabackup 进程各自完成收尾工作，如资源的释放、写备份元数据信息等，innobackupex 等待xtrabackup 子进程结束后退出。

在上面描述的文件拷贝，都是备份进程直接通过操作系统读取数据文件的，只在执行 SQL 命令时和数据库有交互，基本不影响数据库的运行，在备份非 InnoDB 时会有一段时间只读（如果没有MyISAM表的话，只读时间在几秒左右），在备份 InnoDB 数据文件时，对数据库完全没有影响，是真正的热备。



InnoDB 和非 InnoDB 文件的备份都是通过拷贝文件来做的，但是实现的方式不同，前者是以page为粒度做的(xtrabackup)，后者是 cp 或者 tar 命令(innobackupex)，xtrabackup 在读取每个page时会校验 checksum 值，保证数据块是一致的，而innobackupex 在 cp MyISAM 文件时已经做了flush（FTWRL），磁盘上的文件也是完整的，所以最终备份集里的数据文件都是写入完整的。

增量备份
PXB 是支持增量备份的，但是只能对 InnoDB 做增量，InnoDB 每个 page 有个 LSN 号，LSN 是全局递增的，page 被更改时会记录当前的 LSN 号，page中的 LSN 越大，说明当前page越新（最近被更新）。每次备份会记录当前备份到的LSN（xtrabackup_checkpoints 文件中），增量备份就是只拷贝LSN大于上次备份的page，比上次备份小的跳过，每个 ibd 文件最终备份出来的是增量 delta 文件。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
13、BLOB和TEXT之间的区别是什么?
-在BLOB排序和比较中，对BLOB值区分大小写。
-在TEXT文本类型中，不区分大小写进行排序和比较

13.1、BLOB是什么?

- BLOB表示二进制大对象。

-可以保存可变数量的数据。

根据所能容纳的值的最大长度，有四种BLOB类型:

- TINYBLOB

- BLOB

- MEDIUMBLOB

- LONGBLOB

13.2、TEXT数据类型是什么?

TEXT是不区分大小写的BLOB。四种文本类型是：

- TINYTEXT

- TEXT

- MEDIUMTEXT

- LONGTEXT
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
14、MySQL常见监控项。
操作系统层面
CPU
内存
IO
网卡

MySQL层面
MySQL是否运行
连接数
qps
tps
慢查询数
打开表数
当前脏页数
锁情况
主从同步状态（包括Slave_IO_Running、Slave_SQL_Running、Seconds_Behind_Master等

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
15、简单说一下 MySQL5.7有哪些新特性。

从MySQL 5.7开始，root用户的密码不再是空，而是随机产生一个密码
支持JSON
MySQL5.7.6支持使用 generated columns（p1875），这一列由其他列计算而得
sys schema
可以知道哪些语句使用了临时表，哪个用户请求了最多的io，哪个线程占用了最多的内存
索引利用率和冗余索引统计冗余索引
支持将临时表设置为innodb存储引擎
支持虚拟列

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
16、半同步复制与异步复制的区别，在5.7做了哪些增强？

异步复制：主库执行完commit提交操作后，在主库写入binlog日志后即可成功返回客户端，无需等待binlog日志传送给从库。
MySQL5.7之前的半同步复制：主库在每次事物成功提交时，并不及时反馈给前端应用用户，而是等待其中一个从库也接收到binlog事务并成功写入中继日志后（不等待从库应用这部分日志），主库才返回commit操作成功给客户端。
MySQL5.7半同步复制增强：主库将事务写入binlog，传递到从库并写入从库的relay log，主库等待从库反馈接受到relay log的ack之后，再提交事务并且返回commit ok结果给客户端。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
17、数据库高负载的排查和解决办法。

检查操作系统
查看整体负载，使用命令w或者sar -q 1
判断瓶颈在哪个子系统，使用命令w
判断磁盘IO是否较大，使用命令：sar -d 1
判断具体哪个进程消耗的磁盘IO最多，使用命令：iotop

检查MySQL层
查看当前的MySQL查询语句，使用命令：mysqladmin pr|grep -v Sleep
分析slow log
分析慢查询语句

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
19、Explain执行计划中要关注哪些要素？

（1）、type:本次查询表联接类型，从这里可以看到本次查询大概的效率

（2）、key:最终选择的索引，如果没有索引的话，本次查询效率通常很差

（3）、key_len:本次查询用于结果过滤的索引实际长度

（4）、rows:预计需要扫描的记录数，预计需要扫描的记录数越小越好

（5）、extra:额外附加信息，主要确认是否出现 Using filesort、Using temporary 类似情况


20、重做日志和二进制日志的区别（至少三点）

（1）涉及存储引擎不一样：

binlog记录的是所有存储引擎的操作记录

redo log只记录innodb存储引擎的日志

（2）记录内容不一样：

binlog记录的是关于一个事务的具体操作内容。为逻辑日志

而redo log记录的是每个页更改的物理情况

（3）写的时间不一样：

binlog文件仅在事务提交前进行提交，即只写磁盘一次

而在事务进行过程中，却不断有重做日志条目被写入到重做日志文件中。
